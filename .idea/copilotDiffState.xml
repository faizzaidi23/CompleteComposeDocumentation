<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/1_basic.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/1_basic.kt" />
              <option name="originalContent" value="package com.example.FullComposeOfficialDocumentation.Accessibility_9.MergingAndClearing_5&#10;&#10;/*&#10;as accessibility services navigate through elements on the screen&#10;it is important that these elements are grouped or even hidden at the right granularity&#10;when every single low level composable in the screen is highlighted independently, users have&#10;to interact a lot to move across the screen.&#10;If elements merge  together too aggressively users might not understand which elements logically belong together.&#10;if there are elements on the screen that are purely decorative these could be hidden from accessibility services.&#10;In these cases we  can use compose APIs for merging, clearing and hiding semantics&#10;*/" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Accessibility_9.MergingAndClearing_5&#10;&#10;/*&#10;MERGING AND CLEARING SEMANTICS&#10;&#10;As accessibility services navigate through elements on the screen, it is important that&#10;these elements are grouped, separated, or even hidden at the right granularity.&#10;&#10;THE PROBLEM:&#10;- When every single low-level composable in your screen is highlighted independently,&#10;  users have to interact a lot to move across the screen&#10;- If elements merge together too aggressively, users might not understand which&#10;  elements logically belong together&#10;- If there are elements on the screen that are purely decorative, these could be&#10;  hidden from accessibility services&#10;&#10;THE SOLUTION:&#10;Compose provides APIs for merging, clearing, and hiding semantics:&#10;&#10;1. MERGE SEMANTICS (semantics(mergeDescendants = true))&#10;   - Groups multiple composables into a logical unit&#10;   - Accessibility services treat them as one entity&#10;   - Use when children elements constitute a logical and sensible group&#10;&#10;2. CLEAR AND SET SEMANTICS (clearAndSetSemantics)&#10;   - Completely clears or overwrites semantic information&#10;   - Use when creating custom components with specific accessibility needs&#10;   - Can clear all semantics or replace them with new ones&#10;&#10;3. HIDE SEMANTICS (hideFromAccessibility)&#10;   - Hides elements from accessibility services&#10;   - Use for decorative or redundant elements&#10;   - Still keeps semantics for other use cases like testing&#10;&#10;PROPER GRANULARITY IS KEY:&#10;The right balance ensures users can efficiently navigate your app while understanding&#10;the logical structure of the UI elements.&#10;*/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/2_merge_semantics.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/2_merge_semantics.kt" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Accessibility_9.MergingAndClearing_5&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.AccountCircle&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.semantics.semantics&#10;&#10;/*&#10;MERGE SEMANTICS&#10;&#10;When you apply a clickable modifier to a parent composable, Compose automatically&#10;merges all children elements under it. Interactive Compose Material and Foundation&#10;components use merging strategies by default.&#10;&#10;WHEN TO USE MERGE SEMANTICS:&#10;It's common for a component to consist of multiple composables. These composables&#10;could form a logical group and each could contain important information, but you&#10;still might want accessibility services to view them as one element.&#10;&#10;EXAMPLE SCENARIO:&#10;A composable that shows a user's avatar, their name, and some extra information.&#10;Without merging, accessibility services would highlight each element separately,&#10;forcing users to interact with each one individually.&#10;&#10;HOW IT WORKS:&#10;Use the mergeDescendants parameter in the semantics modifier. This way, accessibility&#10;services treat the component as one entity, and all semantics properties of the&#10;descendants are merged.&#10;&#10;MERGING STRATEGY:&#10;Each semantics property has a defined merging strategy:&#10;- ContentDescription: Adds all descendant values to a list&#10;- Text properties: Concatenate into a string&#10;- Other properties: Check their mergePolicy implementation in SemanticsProperties.kt&#10;&#10;Properties can:&#10;- Take on the parent or child value&#10;- Merge the values into a list or string&#10;- Not allow merging at all (throw an exception)&#10;- Use any other custom merging strategy&#10;*/&#10;&#10;/*&#10;Example: Post metadata showing user info&#10;Without merging, each element (avatar, name, date) would be separate&#10;With merging, they form one logical unit&#10;*/&#10;&#10;data class Author(val name: String)&#10;data class Metadata(&#10;    val author: Author,&#10;    val date: String,&#10;    val readTimeMinutes: Int&#10;)&#10;&#10;@Composable&#10;fun PostMetadata(metadata: Metadata) {&#10;    /*&#10;    Merge elements below for accessibility purposes&#10;    This makes accessibility services treat the entire Row as one entity&#10;    instead of focusing on each child individually&#10;    */&#10;    Row(modifier = Modifier.semantics(mergeDescendants = true) {}) {&#10;        /*&#10;        Image is decorative, so contentDescription is null&#10;        It will still be part of the merged semantic node&#10;        */&#10;        Image(&#10;            imageVector = Icons.Filled.AccountCircle,&#10;            contentDescription = null&#10;        )&#10;        &#10;        Column {&#10;            /*&#10;            Both text elements will be merged into the parent Row&#10;            Accessibility services will read them together as one unit&#10;            */&#10;            Text(metadata.author.name)&#10;            Text(&quot;${metadata.date} • ${metadata.readTimeMinutes} min read&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;/*&#10;RESULT:&#10;Accessibility services now focus on the whole container at once and merge its contents.&#10;Instead of navigating through avatar → name → date separately, users experience them&#10;as one cohesive element.&#10;&#10;ACCESSIBILITY ANNOUNCEMENT EXAMPLE (TalkBack):&#10;&quot;John Doe, February 13, 2026 • 5 min read&quot;&#10;(All information announced together in one go)&#10;*/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/3_nested_clickables.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/3_nested_clickables.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Accessibility_9.MergingAndClearing_5&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;&#10;/*&#10;WHEN MERGING DOESN'T HAPPEN - NESTED CLICKABLES&#10;&#10;There are scenarios where you expect children semantics to be merged into a parent,&#10;but that doesn't happen. This is often due to nested interactive elements.&#10;&#10;THE RULE:&#10;A parent cannot merge its children when the children are also merging, either from:&#10;- Setting mergeDescendants = true explicitly&#10;- Being components which merge themselves (like buttons or clickables)&#10;&#10;EXAMPLE SCENARIO:&#10;A list item with:&#10;- A clickable parent Row (opens article)&#10;- An image thumbnail&#10;- Article details text&#10;- A nested BookmarkButton (bookmarks article)&#10;&#10;WHAT HAPPENS:&#10;- The image and article details merge with the parent Row&#10;- The BookmarkButton defies the merge due to its own clickable modifier&#10;- Result: Two separate focusable elements for accessibility services&#10;*/&#10;&#10;/*&#10;Example: Article list item with nested clickable button&#10;*/&#10;&#10;@Composable&#10;fun ArticleListItem(&#10;    openArticle: () -&gt; Unit,&#10;    addToBookmarks: () -&gt; Unit,&#10;) {&#10;    /*&#10;    The parent Row is clickable - it will try to merge its children&#10;    */&#10;    Row(modifier = Modifier.clickable { openArticle() }) {&#10;        /*&#10;        This Icon merges with parent clickable&#10;        It becomes part of the larger clickable article item&#10;        */&#10;        Icon(&#10;            imageVector = Icons.Filled.Star,&#10;            contentDescription = &quot;Article thumbnail&quot;&#10;        )&#10;        &#10;        /*&#10;        Article details also merge with the parent&#10;        They're part of the main article clickable area&#10;        */&#10;        ArticleDetails()&#10;&#10;        /*&#10;        This BookmarkButton defies the merge due to its own clickable modifier&#10;        It remains a separate focusable element for accessibility services&#10;        Why? Because clickable modifiers automatically set mergeDescendants = true&#10;        */&#10;        BookmarkButton(onClick = addToBookmarks)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ArticleDetails() {&#10;    /*&#10;    Implementation of article details&#10;    This would contain title, excerpt, date, etc.&#10;    */&#10;    Text(&quot;Article Title&quot;)&#10;}&#10;&#10;@Composable&#10;fun BookmarkButton(onClick: () -&gt; Unit) {&#10;    /*&#10;    This button has its own clickable behavior&#10;    It will NOT merge with the parent Row&#10;    */&#10;    Icon(&#10;        imageVector = Icons.Filled.Star,&#10;        contentDescription = &quot;Bookmark&quot;,&#10;        modifier = Modifier.clickable { onClick() }&#10;    )&#10;}&#10;&#10;/*&#10;SEMANTICS TREE RESULT:&#10;&#10;MERGED TREE:&#10;Row (clickable - opens article)&#10;  ├─ Icon: &quot;Article thumbnail&quot;&#10;  ├─ ArticleDetails (merged texts)&#10;  &#10;BookmarkButton (separate clickable - bookmarks article)&#10;  └─ Icon: &quot;Bookmark&quot;&#10;&#10;UNMERGED TREE:&#10;Row&#10;  ├─ Icon: &quot;Article thumbnail&quot;&#10;  ├─ Column (ArticleDetails)&#10;  │   ├─ Text: &quot;Article Title&quot;&#10;  │   ├─ Text: &quot;Article excerpt...&quot;&#10;  │   └─ Text: &quot;5 min read&quot;&#10;  └─ Icon (BookmarkButton)&#10;      └─ contentDescription: &quot;Bookmark&quot;&#10;&#10;ACCESSIBILITY EXPERIENCE:&#10;- First focus: &quot;Article thumbnail, Article Title, Article excerpt, 5 min read. Double tap to activate&quot;&#10;- Second focus: &quot;Bookmark. Double tap to activate&quot;&#10;&#10;This separation makes sense because users need to:&#10;1. Open the article (tap the row)&#10;2. OR bookmark it (tap the bookmark button)&#10;These are two distinct actions that shouldn't be merged.&#10;*/&#10;&#10;/*&#10;KEY TAKEAWAY:&#10;Knowing how certain APIs merge or defy merging can help you debug some potentially&#10;unexpected behaviors. Use merging when children elements constitute a logical and&#10;sensible group under their parent. But if the nested children need manual adjusting&#10;or removal of their own semantics, other APIs might better suit your needs&#10;(for example, clearAndSetSemantics).&#10;*/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/4_clear_and_set_semantics.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/4_clear_and_set_semantics.kt" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Accessibility_9.MergingAndClearing_5&#10;&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.foundation.selection.toggleable&#10;import androidx.compose.ui.semantics.Role&#10;import androidx.compose.ui.semantics.clearAndSetSemantics&#10;import androidx.compose.ui.semantics.role&#10;import androidx.compose.ui.semantics.stateDescription&#10;import androidx.compose.ui.state.ToggleableState&#10;import androidx.compose.ui.semantics.toggleableState&#10;&#10;/*&#10;CLEAR AND SET SEMANTICS&#10;&#10;If semantic information needs to be completely cleared or overwritten, a powerful&#10;API to use is clearAndSetSemantics.&#10;&#10;WHEN TO USE:&#10;- When a component needs its own and descendant semantics cleared&#10;- When semantics must be overwritten with custom information&#10;- When creating custom components with specific accessibility needs&#10;- When merging is not sufficient and you need to provide additional information&#10;&#10;HOW IT WORKS:&#10;1. Clear semantics: Use with an empty lambda&#10;   clearAndSetSemantics {}&#10;   &#10;2. Overwrite semantics: Include new content inside the lambda&#10;   clearAndSetSemantics { /* new semantic information */ }&#10;&#10;IMPORTANT NOTES:&#10;- When clearing with empty lambda: No semantics are sent to ANY consumer&#10;  (accessibility, autofill, testing)&#10;- When overwriting: New semantics replace ALL previous semantics of the&#10;  element and its descendants&#10;- Use sparingly: Services receive no original information when this API is set&#10;- Ordering matters: This API clears all semantics that are after where it is applied,&#10;  regardless of other merging strategies&#10;- Semantics info can be used by AI agents and similar services to understand the screen,&#10;  so only clear when necessary&#10;*/&#10;&#10;/*&#10;Example: Custom toggle component&#10;A row with an icon and text that acts as a toggleable element&#10;&#10;THE PROBLEM:&#10;Although the icon and text have some semantic information, together they don't&#10;indicate that this component is a toggleable. Merging is not sufficient because&#10;we must provide additional information about the component.&#10;&#10;THE SOLUTION:&#10;Use clearAndSetSemantics to:&#10;1. Clear the original semantics (icon + text)&#10;2. Set new semantics that properly describe this as a toggleable component&#10;3. Add stateDescription, toggleableState, and role&#10;*/&#10;&#10;@Composable&#10;fun FavoriteToggle() {&#10;    val checked = remember { mutableStateOf(true) }&#10;    &#10;    Row(&#10;        modifier = Modifier&#10;            /*&#10;            First, make the row toggleable with the toggleable modifier&#10;            This provides the basic interaction behavior&#10;            */&#10;            .toggleable(&#10;                value = checked.value,&#10;                onValueChange = { checked.value = it }&#10;            )&#10;            /*&#10;            Then, clear original semantics and set custom ones&#10;            This ensures accessibility services understand this is a toggle/switch&#10;            */&#10;            .clearAndSetSemantics {&#10;                /*&#10;                stateDescription: Describes the current state in human-readable form&#10;                Better than just &quot;On/Off&quot; - provides context&#10;                */&#10;                stateDescription = if (checked.value) &quot;Favorited&quot; else &quot;Not favorited&quot;&#10;                &#10;                /*&#10;                toggleableState: Indicates this is a toggleable component&#10;                and its current state (on/off)&#10;                */&#10;                toggleableState = ToggleableState(checked.value)&#10;                &#10;                /*&#10;                role: Tells accessibility services what type of component this is&#10;                Role.Switch makes TalkBack announce &quot;Double tap to toggle&quot;&#10;                instead of the generic &quot;Double tap to activate&quot;&#10;                */&#10;                role = Role.Switch&#10;            },&#10;    ) {&#10;        /*&#10;        Icon semantics are cleared by clearAndSetSemantics above&#10;        No need for contentDescription here - it would be ignored anyway&#10;        */&#10;        Icon(&#10;            imageVector = Icons.Default.Favorite,&#10;            contentDescription = null&#10;        )&#10;        &#10;        /*&#10;        Text semantics are also cleared by clearAndSetSemantics above&#10;        The text is still visible but its semantics are replaced&#10;        */&#10;        Text(&quot;Favorite?&quot;)&#10;    }&#10;}&#10;&#10;/*&#10;RESULT:&#10;By clearing the original semantics and setting new, more descriptive ones,&#10;accessibility services can now see that this is a toggleable component&#10;that can alternate state.&#10;&#10;ACCESSIBILITY ANNOUNCEMENT (TalkBack):&#10;When focused: &quot;Favorited, Switch, Double tap to toggle&quot;&#10;or&#10;When focused: &quot;Not favorited, Switch, Double tap to toggle&quot;&#10;&#10;COMPARISON:&#10;WITHOUT clearAndSetSemantics:&#10;- TalkBack might announce: &quot;Favorite icon, Favorite?, Double tap to activate&quot;&#10;- Users don't know it's toggleable or what state it's in&#10;&#10;WITH clearAndSetSemantics:&#10;- TalkBack announces: &quot;Favorited, Switch, Double tap to toggle&quot;&#10;- Clear indication it's a toggleable switch with current state&#10;*/&#10;&#10;/*&#10;CONSIDERATIONS WHEN USING clearAndSetSemantics:&#10;&#10;1. Use sparingly - only when necessary&#10;   Because services receive no information when this API is set&#10;&#10;2. Custom semantics may be set within the API lambda&#10;   You can add any relevant semantics properties&#10;&#10;3. Ordering of modifiers matters&#10;   This API clears all semantics that are after where it is applied&#10;&#10;4. Think about all use cases&#10;   - Accessibility services (TalkBack, Switch Access)&#10;   - Testing framework&#10;   - Future AI agents&#10;   - Autofill services&#10;*/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/5_hide_semantics.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/5_hide_semantics.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Accessibility_9.MergingAndClearing_5&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.semantics.semantics&#10;import androidx.compose.ui.semantics.invisibleToUser&#10;import androidx.compose.material3.Text&#10;&#10;/*&#10;HIDE SEMANTICS&#10;&#10;In some scenarios, elements don't need to be sent to accessibility services.&#10;Perhaps their additional information is redundant for accessibility, or it is&#10;purely visually decorative and non-interactive.&#10;&#10;WHEN TO USE invisibleToUser:&#10;- Decorative elements that don't convey important information&#10;- Redundant elements that duplicate information already available&#10;- Visual separators (dots, lines) used only for aesthetics&#10;- Watermarks or background elements&#10;- Elements that would clutter the accessibility experience&#10;&#10;HOW IT WORKS:&#10;Use the invisibleToUser() function within a semantics modifier:&#10;Modifier.semantics { invisibleToUser() }&#10;&#10;KEY DIFFERENCE FROM clearAndSetSemantics:&#10;- invisibleToUser: Hides from accessibility services but keeps semantics&#10;  for other use cases (like testing)&#10;- clearAndSetSemantics{}: Clears semantics for ALL services including testing&#10;&#10;BENEFITS:&#10;- Reduces noise for accessibility service users&#10;- Keeps testing capabilities intact&#10;- Improves navigation efficiency&#10;- Focuses attention on meaningful content&#10;*/&#10;&#10;/*&#10;EXAMPLE 1: WATERMARK&#10;A watermark that spans a component is purely visual and redundant.&#10;Users don't need to know about it when navigating with accessibility services.&#10;*/&#10;&#10;@Composable&#10;fun WatermarkExample(&#10;    watermarkText: String,&#10;) {&#10;    Box {&#10;        /*&#10;        Main content that users should interact with&#10;        This remains fully accessible&#10;        */&#10;        WatermarkedContent()&#10;        &#10;        /*&#10;        Watermark text is marked as hidden to accessibility services&#10;        It's still rendered visually and can be tested, but accessibility&#10;        services won't announce it or focus on it&#10;        */&#10;        WatermarkText(&#10;            text = watermarkText,&#10;            color = Color.Gray.copy(alpha = 0.5f),&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .semantics { invisibleToUser() }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WatermarkedContent() {&#10;    /*&#10;    Main content implementation&#10;    This is what users actually interact with&#10;    */&#10;    Text(&quot;Important content that users need to access&quot;)&#10;}&#10;&#10;@Composable&#10;fun WatermarkText(&#10;    text: String,&#10;    color: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    /*&#10;    Watermark text implementation&#10;    Visible on screen but hidden from accessibility services&#10;    */&#10;    Text(&#10;        text = text,&#10;        color = color,&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;/*&#10;EXAMPLE 2: DECORATIVE SEPARATOR&#10;A character used to decoratively separate information, like &quot;•&quot; or &quot;|&quot;&#10;This is purely visual and doesn't need to be announced&#10;*/&#10;&#10;@Composable&#10;fun DecorativeExample() {&#10;    Text(&#10;        modifier = Modifier.semantics {&#10;            invisibleToUser()&#10;        },&#10;        text = &quot;A dot character that is used to decoratively separate information, like •&quot;&#10;    )&#10;}&#10;&#10;/*&#10;PRACTICAL EXAMPLE: Article metadata with decorative separator&#10;*/&#10;&#10;@Composable&#10;fun ArticleMetadataWithSeparator(date: String, readTime: String) {&#10;    /*&#10;    Without hiding the separator:&#10;    TalkBack might announce: &quot;February 13, 2026, bullet, 5 min read&quot;&#10;    &#10;    With hiding the separator:&#10;    TalkBack announces: &quot;February 13, 2026, 5 min read&quot;&#10;    (Much cleaner and more natural)&#10;    */&#10;    Text(date)&#10;    Text(&#10;        text = &quot; • &quot;,&#10;        modifier = Modifier.semantics { invisibleToUser() }&#10;    )&#10;    Text(readTime)&#10;}&#10;&#10;/*&#10;COMMON USE CASES FOR invisibleToUser:&#10;&#10;1. DECORATIVE ICONS&#10;   - Icons that are purely visual and duplicate adjacent text&#10;   - Background patterns or textures&#10;&#10;2. VISUAL SEPARATORS&#10;   - Bullets (•), pipes (|), slashes (/)&#10;   - Decorative divider lines&#10;   - Spacing elements&#10;&#10;3. WATERMARKS AND OVERLAYS&#10;   - Copyright notices&#10;   - Draft watermarks&#10;   - Background branding&#10;&#10;4. REDUNDANT INFORMATION&#10;   - Icons next to text that describes the same thing&#10;   - Example: Star icon next to &quot;Favorite&quot; text&#10;   - The text alone is sufficient for accessibility&#10;&#10;5. DECORATIVE IMAGES&#10;   - Background images&#10;   - Texture overlays&#10;   - Design elements with no semantic meaning&#10;&#10;WHEN NOT TO USE:&#10;- Don't hide interactive elements (buttons, links)&#10;- Don't hide informative images (use contentDescription instead)&#10;- Don't hide text that conveys unique information&#10;- Don't hide status indicators or badges&#10;*/&#10;&#10;/*&#10;COMPARISON TABLE:&#10;&#10;┌─────────────────────┬────────────────┬─────────┬──────────┐&#10;│ API                 │ Accessibility  │ Testing │ Use Case │&#10;├─────────────────────┼────────────────┼─────────┼──────────┤&#10;│ invisibleToUser     │ Hidden         │ Visible │ Decorative│&#10;│ clearAndSetSemantics{}│ Cleared      │ Cleared │ Remove all│&#10;│ clearAndSetSemantics{...}│ Custom   │ Custom  │ Override  │&#10;│ semantics(mergeDescendants)│ Merged │ Merged  │ Group     │&#10;└─────────────────────┴────────────────┴─────────┴──────────┘&#10;&#10;ACCESSIBILITY RESULT:&#10;Using invisibleToUser ensures decorative elements are hidden from&#10;accessibility services, but still keep their semantics for other use cases,&#10;like testing. This creates a cleaner, more focused experience for users&#10;relying on accessibility services.&#10;*/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/6_breakdown_use_cases.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Accessibility_9/MergingAndClearing_5/6_breakdown_use_cases.kt" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Accessibility_9.MergingAndClearing_5&#10;&#10;/*&#10;BREAKDOWN OF USE CASES&#10;&#10;Summary of use cases to understand how to clearly differentiate between the APIs&#10;for merging, clearing, and hiding semantics.&#10;&#10;═══════════════════════════════════════════════════════════════════════════════&#10;1. WHEN CONTENT IS NOT INTENDED TO BE USED BY ACCESSIBILITY SERVICES&#10;═══════════════════════════════════════════════════════════════════════════════&#10;&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│ USE hideFromAccessibility                                                   │&#10;├─────────────────────────────────────────────────────────────────────────────┤&#10;│ WHEN: Content is possibly decorative or redundant, but still must be tested│&#10;│                                                                             │&#10;│ EXAMPLES:                                                                   │&#10;│ - Watermarks on images                                                      │&#10;│ - Decorative separators (•, |, /)                                          │&#10;│ - Background patterns                                                       │&#10;│ - Redundant icons next to descriptive text                                  │&#10;│                                                                             │&#10;│ CODE:                                                                       │&#10;│   Modifier.semantics { hideFromAccessibility() }                           │&#10;│                                                                             │&#10;│ RESULT:                                                                     │&#10;│ - Hidden from accessibility services ✓                                      │&#10;│ - Still available for testing ✓                                             │&#10;│ - Rendered visually ✓                                                       │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│ USE clearAndSetSemantics{} with EMPTY LAMBDA                               │&#10;├─────────────────────────────────────────────────────────────────────────────┤&#10;│ WHEN: Parent and children semantics need to be cleared for ALL services    │&#10;│                                                                             │&#10;│ EXAMPLES:                                                                   │&#10;│ - Completely non-interactive decorative containers                          │&#10;│ - Elements that should be invisible to all semantic consumers               │&#10;│                                                                             │&#10;│ CODE:                                                                       │&#10;│   Modifier.clearAndSetSemantics {}                                         │&#10;│                                                                             │&#10;│ RESULT:                                                                     │&#10;│ - Hidden from accessibility services ✓                                      │&#10;│ - Cleared from testing ✓                                                    │&#10;│ - Rendered visually ✓                                                       │&#10;│                                                                             │&#10;│ WARNING: Use sparingly - affects testing too!                               │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│ USE clearAndSetSemantics{/*content*/} with CONTENT                         │&#10;├─────────────────────────────────────────────────────────────────────────────┤&#10;│ WHEN: A component's semantics needs to be manually set                      │&#10;│                                                                             │&#10;│ EXAMPLES:                                                                   │&#10;│ - Custom toggle components                                                  │&#10;│ - Custom interactive elements                                               │&#10;│ - Components requiring specific semantic properties                         │&#10;│ - When default semantics don't accurately represent the component           │&#10;│                                                                             │&#10;│ CODE:                                                                       │&#10;│   Modifier.clearAndSetSemantics {                                          │&#10;│       stateDescription = &quot;Custom state&quot;                                    │&#10;│       role = Role.Switch                                                   │&#10;│   }                                                                         │&#10;│                                                                             │&#10;│ RESULT:                                                                     │&#10;│ - Original semantics replaced ✓                                             │&#10;│ - Custom semantics set ✓                                                    │&#10;│ - Better accessibility representation ✓                                     │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;&#10;═══════════════════════════════════════════════════════════════════════════════&#10;2. WHEN CONTENT SHOULD BE TREATED AS ONE ENTITY&#10;═══════════════════════════════════════════════════════════════════════════════&#10;&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│ USE MERGE SEMANTIC DESCENDANTS                                              │&#10;├─────────────────────────────────────────────────────────────────────────────┤&#10;│ WHEN: Content needs all of its children's information to be complete        │&#10;│                                                                             │&#10;│ EXAMPLES:                                                                   │&#10;│ - User profile cards (avatar + name + info)                                 │&#10;│ - List items with multiple text elements                                    │&#10;│ - Article metadata (author + date + read time)                              │&#10;│ - Cards with icon + title + description                                     │&#10;│                                                                             │&#10;│ CODE:                                                                       │&#10;│   Modifier.semantics(mergeDescendants = true) {}                           │&#10;│                                                                             │&#10;│ RESULT:                                                                     │&#10;│ - Children merged into parent ✓                                             │&#10;│ - Single focusable element ✓                                                │&#10;│ - All information announced together ✓                                      │&#10;│ - Efficient navigation ✓                                                    │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;&#10;═══════════════════════════════════════════════════════════════════════════════&#10;3. DECISION TREE&#10;═══════════════════════════════════════════════════════════════════════════════&#10;&#10;START: Does the element need to be accessible?&#10;│&#10;├─ NO → Is it needed for testing?&#10;│   │&#10;│   ├─ YES → Use hideFromAccessibility()&#10;│   │          (Hides from a11y, keeps for testing)&#10;│   │&#10;│   └─ NO → Use clearAndSetSemantics {}&#10;│              (Clears from everything)&#10;│&#10;└─ YES → Does it have multiple child elements?&#10;    │&#10;    ├─ YES → Should children be grouped?&#10;    │   │&#10;    │   ├─ YES → Use semantics(mergeDescendants = true)&#10;    │   │          (Group children into one entity)&#10;    │   │&#10;    │   └─ NO → Keep separate&#10;    │              (Each child is independently accessible)&#10;    │&#10;    └─ NO → Are default semantics correct?&#10;        │&#10;        ├─ YES → Do nothing&#10;        │          (Use default semantics)&#10;        │&#10;        └─ NO → Use clearAndSetSemantics { /* custom */ }&#10;                   (Replace with custom semantics)&#10;&#10;═══════════════════════════════════════════════════════════════════════════════&#10;4. QUICK REFERENCE COMPARISON TABLE&#10;═══════════════════════════════════════════════════════════════════════════════&#10;&#10;┌──────────────────────┬──────────────┬─────────┬──────────┬─────────────────┐&#10;│ API                  │ Accessibility│ Testing │ Visual   │ Best For        │&#10;├──────────────────────┼──────────────┼─────────┼──────────┼─────────────────┤&#10;│ hideFromAccessibility│ Hidden       │ Visible │ Visible  │ Decorative      │&#10;│                      │              │         │          │ elements        │&#10;├──────────────────────┼──────────────┼─────────┼──────────┼─────────────────┤&#10;│ clearAndSetSemantics │ Cleared      │ Cleared │ Visible  │ Complete        │&#10;│ (empty)              │              │         │          │ removal         │&#10;├──────────────────────┼──────────────┼─────────┼──────────┼─────────────────┤&#10;│ clearAndSetSemantics │ Custom       │ Custom  │ Visible  │ Custom          │&#10;│ (with content)       │              │         │          │ components      │&#10;├──────────────────────┼──────────────┼─────────┼──────────┼─────────────────┤&#10;│ semantics            │ Merged       │ Merged  │ Visible  │ Grouping        │&#10;│ (mergeDescendants)   │              │         │          │ related content │&#10;└──────────────────────┴──────────────┴─────────┴──────────┴─────────────────┘&#10;&#10;═══════════════════════════════════════════════════════════════════════════════&#10;5. COMMON PATTERNS AND RECIPES&#10;═══════════════════════════════════════════════════════════════════════════════&#10;&#10;PATTERN 1: User Profile Card&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│ Row(Modifier.semantics(mergeDescendants = true)) {                         │&#10;│     Image(contentDescription = null) // Avatar                             │&#10;│     Column {                                                                │&#10;│         Text(&quot;John Doe&quot;)                                                    │&#10;│         Text(&quot;Software Engineer&quot;)                                           │&#10;│     }                                                                       │&#10;│ }                                                                           │&#10;│ Result: &quot;John Doe, Software Engineer&quot; (announced together)                 │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;&#10;PATTERN 2: Decorative Watermark&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│ Box {                                                                       │&#10;│     MainContent()                                                           │&#10;│     Watermark(Modifier.semantics { hideFromAccessibility() })              │&#10;│ }                                                                           │&#10;│ Result: Only MainContent is announced, watermark is hidden                 │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;&#10;PATTERN 3: Custom Toggle&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│ Row(                                                                        │&#10;│     Modifier                                                                │&#10;│         .toggleable(value, onValueChange)                                  │&#10;│         .clearAndSetSemantics {                                            │&#10;│             stateDescription = if (value) &quot;On&quot; else &quot;Off&quot;                  │&#10;│             role = Role.Switch                                             │&#10;│         }                                                                   │&#10;│ ) {                                                                         │&#10;│     Icon(...)                                                               │&#10;│     Text(&quot;Toggle me&quot;)                                                       │&#10;│ }                                                                           │&#10;│ Result: &quot;On, Switch, Double tap to toggle&quot;                                 │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;&#10;PATTERN 4: List with Nested Actions&#10;┌─────────────────────────────────────────────────────────────────────────────┐&#10;│ Row(Modifier.clickable { openItem() }) {                                   │&#10;│     Image(...)                                                              │&#10;│     Text(&quot;Item title&quot;)                                                      │&#10;│     IconButton(onClick = { bookmark() }) {  // Separate action             │&#10;│         Icon(Icons.Default.Bookmark, &quot;Bookmark&quot;)                           │&#10;│     }                                                                       │&#10;│ }                                                                           │&#10;│ Result: Two separate focusable elements (row + button)                     │&#10;└─────────────────────────────────────────────────────────────────────────────┘&#10;&#10;═══════════════════════════════════════════════════════════════════════════════&#10;KEY PRINCIPLES&#10;═══════════════════════════════════════════════════════════════════════════════&#10;&#10;1. Start with defaults - Most components have good semantics by default&#10;2. Test with TalkBack - Always verify with real accessibility services&#10;3. Less is more - Don't over-merge or over-hide&#10;4. Think like a user - Would this grouping make sense when navigating?&#10;5. Document custom semantics - Explain why you're overriding defaults&#10;6. Consider testing - Some APIs affect test discoverability&#10;7. Respect merging rules - Nested clickables don't merge automatically&#10;*/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Graphics_7/6_drawImage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Graphics_7/6_drawImage.kt" />
              <option name="originalContent" value="package com.example.FullComposeOfficialDocumentation.Graphics_7&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.ImageBitmap&#10;import androidx.compose.ui.res.imageResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.FullComposeOfficialDocumentation.R&#10;&#10;/*&#10;DRAW IMAGE&#10;&#10;To draw an ImageBitmap with DrawScope&#10;load up the image using ImageBitmap.imageResource&#10;and then call drawImage&#10;&#10;Note: See the Image customization documentation for more information&#10;on how to apply filters to your images&#10;*/&#10;&#10;/*&#10;Basic image drawing&#10;&#10;This is the simplest way to draw an image on canvas&#10;*/&#10;&#10;@Composable&#10;fun BasicDrawImageExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;&#10;    Canvas(modifier = Modifier.fillMaxSize(), onDraw = {&#10;        drawImage(dogImage)&#10;    })&#10;}&#10;&#10;/*&#10;Drawing image with specific size&#10;&#10;You can specify the destination size to scale the image&#10;*/&#10;&#10;@Composable&#10;fun DrawImageWithSizeExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;&#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        drawImage(&#10;            image = dogImage,&#10;            dstSize = IntSize(200.dp.toPx().toInt(), 200.dp.toPx().toInt())&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Drawing image at specific position&#10;&#10;You can position the image anywhere on the canvas using dstOffset&#10;*/&#10;&#10;@Composable&#10;fun DrawImageAtPositionExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;&#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        drawImage(&#10;            image = dogImage,&#10;            dstOffset = IntOffset(50.dp.toPx().toInt(), 50.dp.toPx().toInt()),&#10;            dstSize = IntSize(150.dp.toPx().toInt(), 150.dp.toPx().toInt())&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Drawing image with alpha transparency&#10;&#10;You can adjust the opacity of the image using the alpha parameter&#10;*/&#10;&#10;@Composable&#10;fun DrawImageWithAlphaExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;&#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        drawImage(&#10;            image = dogImage,&#10;            alpha = 0.5f&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Drawing multiple images&#10;&#10;You can draw multiple images at different positions and sizes&#10;*/&#10;&#10;@Composable&#10;fun MultipleImagesExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;&#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        /* Large image in background */&#10;        drawImage(&#10;            image = dogImage,&#10;            dstSize = IntSize(size.width.toInt(), size.height.toInt()),&#10;            alpha = 0.3f&#10;        )&#10;&#10;        /* Small image in top-left */&#10;        drawImage(&#10;            image = dogImage,&#10;            dstOffset = IntOffset(10.dp.toPx().toInt(), 10.dp.toPx().toInt()),&#10;            dstSize = IntSize(80.dp.toPx().toInt(), 80.dp.toPx().toInt())&#10;        )&#10;&#10;        /* Small image in bottom-right */&#10;        drawImage(&#10;            image = dogImage,&#10;            dstOffset = IntOffset(&#10;                (size.width - 90.dp.toPx()).toInt(),&#10;                (size.height - 90.dp.toPx()).toInt()&#10;            ),&#10;            dstSize = IntSize(80.dp.toPx().toInt(), 80.dp.toPx().toInt())&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Drawing part of an image (source rectangle)&#10;&#10;You can draw only a portion of the source image using srcOffset and srcSize&#10;This is useful for sprite sheets or extracting specific parts of an image&#10;*/&#10;&#10;@Composable&#10;fun DrawImagePartExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;&#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        /* Draw only the center portion of the image */&#10;        drawImage(&#10;            image = dogImage,&#10;            srcOffset = IntOffset(&#10;                dogImage.width / 4,&#10;                dogImage.height / 4&#10;            ),&#10;            srcSize = IntSize(&#10;                dogImage.width / 2,&#10;                dogImage.height / 2&#10;            ),&#10;            dstSize = IntSize(&#10;                200.dp.toPx().toInt(),&#10;                200.dp.toPx().toInt()&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Image tiled pattern&#10;&#10;This creates a tiled pattern by drawing the image multiple times&#10;*/&#10;&#10;@Composable&#10;fun ImageTiledPatternExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;&#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        val tileSize = 75.dp.toPx().toInt()&#10;        val tilesX = (size.width / tileSize).toInt()&#10;        val tilesY = (size.height / tileSize).toInt()&#10;&#10;        for (y in 0 until tilesY) {&#10;            for (x in 0 until tilesX) {&#10;                drawImage(&#10;                    image = dogImage,&#10;                    dstOffset = IntOffset(x * tileSize, y * tileSize),&#10;                    dstSize = IntSize(tileSize, tileSize),&#10;                    alpha = 0.6f&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/*&#10;Image with transformation&#10;&#10;You can combine image drawing with transformations&#10;*/&#10;&#10;@Composable&#10;fun ImageWithTransformExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;&#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        rotate(degrees = 45f, pivot = Offset(size.width / 2, size.height / 2)) {&#10;            drawImage(&#10;                image = dogImage,&#10;                dstOffset = IntOffset(&#10;                    (size.width / 4).toInt(),&#10;                    (size.height / 4).toInt()&#10;                ),&#10;                dstSize = IntSize(&#10;                    (size.width / 2).toInt(),&#10;                    (size.height / 2).toInt()&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/*&#10;Display all draw image examples&#10;*/&#10;&#10;@Composable&#10;fun AllDrawImageExamples() {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.spacedBy(24.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Draw Image Examples&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Use ImageBitmap.imageResource and drawImage&quot;,&#10;            fontSize = 14.sp&#10;        )&#10;&#10;        Text(text = &quot;Basic Draw Image&quot;, fontWeight = FontWeight.Medium)&#10;        BasicDrawImageExample()&#10;&#10;        Text(text = &quot;Image with Specific Size&quot;, fontWeight = FontWeight.Medium)&#10;        DrawImageWithSizeExample()&#10;&#10;        Text(text = &quot;Image at Position&quot;, fontWeight = FontWeight.Medium)&#10;        DrawImageAtPositionExample()&#10;&#10;        Text(text = &quot;Image with Alpha&quot;, fontWeight = FontWeight.Medium)&#10;        DrawImageWithAlphaExample()&#10;&#10;        Text(text = &quot;Multiple Images&quot;, fontWeight = FontWeight.Medium)&#10;        MultipleImagesExample()&#10;&#10;        Text(text = &quot;Draw Part of Image&quot;, fontWeight = FontWeight.Medium)&#10;        DrawImagePartExample()&#10;&#10;        Text(text = &quot;Tiled Pattern&quot;, fontWeight = FontWeight.Medium)&#10;        ImageTiledPatternExample()&#10;&#10;        Text(text = &quot;Image with Rotation&quot;, fontWeight = FontWeight.Medium)&#10;        ImageWithTransformExample()&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Graphics_7&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.ImageBitmap&#10;import androidx.compose.ui.res.imageResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.example.FullComposeOfficialDocumentation.R&#10;&#10;/*&#10;DRAW IMAGE&#10;&#10;To draw an ImageBitmap with DrawScope&#10;load up the image using ImageBitmap.imageResource&#10;and then call drawImage&#10;&#10;Note: See the Image customization documentation for more information&#10;on how to apply filters to your images&#10;*/&#10;&#10;/*&#10;Basic image drawing&#10;&#10;This is the simplest way to draw an image on canvas&#10;*/&#10;&#10;@Composable&#10;fun BasicDrawImageExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;    &#10;    Canvas(modifier = Modifier.fillMaxSize(), onDraw = {&#10;        drawImage(dogImage)&#10;    })&#10;}&#10;&#10;/*&#10;Drawing image with specific size&#10;&#10;You can specify the destination size to scale the image&#10;*/&#10;&#10;@Composable&#10;fun DrawImageWithSizeExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;    &#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        drawImage(&#10;            image = dogImage,&#10;            dstSize = IntSize(200.dp.toPx().toInt(), 200.dp.toPx().toInt())&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Drawing image at specific position&#10;&#10;You can position the image anywhere on the canvas using dstOffset&#10;*/&#10;&#10;@Composable&#10;fun DrawImageAtPositionExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;    &#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        drawImage(&#10;            image = dogImage,&#10;            dstOffset = IntOffset(50.dp.toPx().toInt(), 50.dp.toPx().toInt()),&#10;            dstSize = IntSize(150.dp.toPx().toInt(), 150.dp.toPx().toInt())&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Drawing image with alpha transparency&#10;&#10;You can adjust the opacity of the image using the alpha parameter&#10;*/&#10;&#10;@Composable&#10;fun DrawImageWithAlphaExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;    &#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        drawImage(&#10;            image = dogImage,&#10;            alpha = 0.5f&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Drawing multiple images&#10;&#10;You can draw multiple images at different positions and sizes&#10;*/&#10;&#10;@Composable&#10;fun MultipleImagesExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;    &#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        /* Large image in background */&#10;        drawImage(&#10;            image = dogImage,&#10;            dstSize = IntSize(size.width.toInt(), size.height.toInt()),&#10;            alpha = 0.3f&#10;        )&#10;        &#10;        /* Small image in top-left */&#10;        drawImage(&#10;            image = dogImage,&#10;            dstOffset = IntOffset(10.dp.toPx().toInt(), 10.dp.toPx().toInt()),&#10;            dstSize = IntSize(80.dp.toPx().toInt(), 80.dp.toPx().toInt())&#10;        )&#10;        &#10;        /* Small image in bottom-right */&#10;        drawImage(&#10;            image = dogImage,&#10;            dstOffset = IntOffset(&#10;                (size.width - 90.dp.toPx()).toInt(),&#10;                (size.height - 90.dp.toPx()).toInt()&#10;            ),&#10;            dstSize = IntSize(80.dp.toPx().toInt(), 80.dp.toPx().toInt())&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Drawing part of an image (source rectangle)&#10;&#10;You can draw only a portion of the source image using srcOffset and srcSize&#10;This is useful for sprite sheets or extracting specific parts of an image&#10;*/&#10;&#10;@Composable&#10;fun DrawImagePartExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;    &#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        /* Draw only the center portion of the image */&#10;        drawImage(&#10;            image = dogImage,&#10;            srcOffset = IntOffset(&#10;                dogImage.width / 4,&#10;                dogImage.height / 4&#10;            ),&#10;            srcSize = IntSize(&#10;                dogImage.width / 2,&#10;                dogImage.height / 2&#10;            ),&#10;            dstSize = IntSize(&#10;                200.dp.toPx().toInt(),&#10;                200.dp.toPx().toInt()&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;/*&#10;Image tiled pattern&#10;&#10;This creates a tiled pattern by drawing the image multiple times&#10;*/&#10;&#10;@Composable&#10;fun ImageTiledPatternExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;    &#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        val tileSize = 75.dp.toPx().toInt()&#10;        val tilesX = (size.width / tileSize).toInt()&#10;        val tilesY = (size.height / tileSize).toInt()&#10;        &#10;        for (y in 0 until tilesY) {&#10;            for (x in 0 until tilesX) {&#10;                drawImage(&#10;                    image = dogImage,&#10;                    dstOffset = IntOffset(x * tileSize, y * tileSize),&#10;                    dstSize = IntSize(tileSize, tileSize),&#10;                    alpha = 0.6f&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/*&#10;Image with transformation&#10;&#10;You can combine image drawing with transformations&#10;*/&#10;&#10;@Composable&#10;fun ImageWithTransformExample() {&#10;    val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)&#10;    &#10;    Canvas(modifier = Modifier.size(300.dp)) {&#10;        withTransform({&#10;            rotate(degrees = 45f, pivot = Offset(size.width / 2, size.height / 2))&#10;        }) {&#10;            drawImage(&#10;                image = dogImage,&#10;                dstOffset = IntOffset(&#10;                    (size.width / 4).toInt(),&#10;                    (size.height / 4).toInt()&#10;                ),&#10;                dstSize = IntSize(&#10;                    (size.width / 2).toInt(),&#10;                    (size.height / 2).toInt()&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/*&#10;Display all draw image examples&#10;*/&#10;&#10;@Composable&#10;fun AllDrawImageExamples() {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.spacedBy(24.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Draw Image Examples&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;        &#10;        Text(&#10;            text = &quot;Use ImageBitmap.imageResource and drawImage&quot;,&#10;            fontSize = 14.sp&#10;        )&#10;        &#10;        Text(text = &quot;Basic Draw Image&quot;, fontWeight = FontWeight.Medium)&#10;        BasicDrawImageExample()&#10;        &#10;        Text(text = &quot;Image with Specific Size&quot;, fontWeight = FontWeight.Medium)&#10;        DrawImageWithSizeExample()&#10;        &#10;        Text(text = &quot;Image at Position&quot;, fontWeight = FontWeight.Medium)&#10;        DrawImageAtPositionExample()&#10;        &#10;        Text(text = &quot;Image with Alpha&quot;, fontWeight = FontWeight.Medium)&#10;        DrawImageWithAlphaExample()&#10;        &#10;        Text(text = &quot;Multiple Images&quot;, fontWeight = FontWeight.Medium)&#10;        MultipleImagesExample()&#10;        &#10;        Text(text = &quot;Draw Part of Image&quot;, fontWeight = FontWeight.Medium)&#10;        DrawImagePartExample()&#10;        &#10;        Text(text = &quot;Tiled Pattern&quot;, fontWeight = FontWeight.Medium)&#10;        ImageTiledPatternExample()&#10;        &#10;        Text(text = &quot;Image with Rotation&quot;, fontWeight = FontWeight.Medium)&#10;        ImageWithTransformExample()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>