<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Text_Typography_5/MigrateToStateBased_9/1_BasicMigration.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Text_Typography_5/MigrateToStateBased_9/1_BasicMigration.kt" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Text_Typography_5.MigrateToStateBased_9&#10;&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;&#10;/*&#10; Basic Migration Example&#10; &#10; This file shows the difference between value-based and state-based TextFields&#10; &#10; Value-based (OLD - current implementation):&#10; - Uses String value with onValueChange callback&#10; - State managed with remember/rememberSaveable&#10; - You manually handle state updates&#10; &#10; State-based (NEW - requires newer Compose version):&#10; - Uses TextFieldState object&#10; - State encapsulated in TextFieldState&#10; - No onValueChange callback needed&#10; - Better synchronization with keyboard&#10; &#10; Note: State-based TextField requires Compose Foundation 1.7.0+ and Material3 1.3.0+&#10; Your project currently uses value-based TextField&#10;*/&#10;&#10;/*&#10; VALUE-BASED TextField (Current approach)&#10; &#10; This is what we're using now in this project&#10;*/&#10;@Composable&#10;fun OldSimpleTextField() {&#10;    var state by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    &#10;    TextField(&#10;        value = state,&#10;        onValueChange = { state = it },&#10;        singleLine = true&#10;    )&#10;}&#10;&#10;/*&#10; STATE-BASED TextField (Future approach)&#10; &#10; This is what it would look like after migration&#10; &#10; Changes:&#10; 1. Replace remember { mutableStateOf(&quot;&quot;) } with rememberTextFieldState()&#10; 2. Replace value + onValueChange with state parameter&#10; 3. Replace singleLine = true with lineLimits = TextFieldLineLimits.SingleLine&#10; &#10; Benefits:&#10; - No async issues from onValueChange&#10; - State survives recomposition and process death automatically&#10; - Better keyboard synchronization&#10; - More predictable behavior&#10; &#10; Example (requires newer Compose version):&#10; &#10; @Composable&#10; fun NewSimpleTextField() {&#10;     val state = rememberTextFieldState()&#10;     &#10;     TextField(&#10;         state = state,&#10;         lineLimits = TextFieldLineLimits.SingleLine&#10;     )&#10; }&#10;*/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Text_Typography_5/MigrateToStateBased_9/2_FilteringMigration.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Text_Typography_5/MigrateToStateBased_9/2_FilteringMigration.kt" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Text_Typography_5.MigrateToStateBased_9&#10;&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;&#10;/*&#10; Filtering Input - Migration Example&#10; &#10; Old approach: Filter in onValueChange callback&#10; New approach: Use InputTransformation&#10; &#10; Problem with old approach:&#10; - onValueChange creates async behavior&#10; - Can cause synchronization issues with keyboard&#10; - State update happens after user input&#10; &#10; Benefits of new approach:&#10; - InputTransformation is called immediately after user input&#10; - Changes applied synchronously&#10; - No sync issues with software keyboard&#10; - More predictable behavior&#10;*/&#10;&#10;/*&#10; VALUE-BASED - Filter leading zeros (Current approach)&#10; &#10; Filters out leading zeros as user types&#10; Uses onValueChange callback to manipulate input&#10;*/&#10;@Composable&#10;fun OldNoLeadingZeroes() {&#10;    var input by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    &#10;    TextField(&#10;        value = input,&#10;        onValueChange = { newText -&gt;&#10;            // Filter logic in onValueChange&#10;            input = newText.trimStart { it == '0' }&#10;        }&#10;    )&#10;}&#10;&#10;/*&#10; STATE-BASED - Filter leading zeros (Future approach)&#10; &#10; Migration steps:&#10; 1. Replace value/onValueChange with rememberTextFieldState()&#10; 2. Move filtering logic to InputTransformation&#10; 3. Use TextFieldBuffer to modify state&#10; &#10; Example (requires newer Compose version):&#10; &#10; @Composable&#10; fun NewNoLeadingZeroes() {&#10;     val state = rememberTextFieldState()&#10;     &#10;     TextField(&#10;         state = state,&#10;         inputTransformation = {&#10;             // Use TextFieldBuffer from receiver scope&#10;             // Filter out leading zeros&#10;             if (asCharSequence().firstOrNull() == '0') {&#10;                 delete(0, 1)&#10;             }&#10;         }&#10;     )&#10; }&#10; &#10; Key differences:&#10; - InputTransformation gets TextFieldBuffer in receiver scope&#10; - Can directly modify buffer (delete, insert, replace)&#10; - Changes happen immediately, no async behavior&#10; - Better for complex filtering logic&#10;*/&#10;&#10;/*&#10; More filtering examples (value-based, current approach)&#10;*/&#10;&#10;@Composable&#10;fun FilterDigitsOnly() {&#10;    var input by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    &#10;    TextField(&#10;        value = input,&#10;        onValueChange = { newText -&gt;&#10;            // Only accept digits&#10;            if (newText.all { it.isDigit() }) {&#10;                input = newText&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun FilterMaxLength() {&#10;    var input by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    val maxLength = 10&#10;    &#10;    TextField(&#10;        value = input,&#10;        onValueChange = { newText -&gt;&#10;            // Limit to max length&#10;            if (newText.length &lt;= maxLength) {&#10;                input = newText&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;/*&#10; STATE-BASED equivalents (Future approach)&#10; &#10; For FilterDigitsOnly:&#10; &#10; @Composable&#10; fun NewFilterDigitsOnly() {&#10;     val state = rememberTextFieldState()&#10;     &#10;     TextField(&#10;         state = state,&#10;         inputTransformation = {&#10;             // Revert changes if non-digit found&#10;             if (!asCharSequence().all { it.isDigit() }) {&#10;                 revertAllChanges()&#10;             }&#10;         }&#10;     )&#10; }&#10; &#10; For FilterMaxLength:&#10; &#10; @Composable&#10; fun NewFilterMaxLength() {&#10;     val state = rememberTextFieldState()&#10;     &#10;     TextField(&#10;         state = state,&#10;         inputTransformation = InputTransformation.maxLength(10)&#10;     )&#10; }&#10; &#10; Built-in InputTransformation.maxLength() is provided&#10;*/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Text_Typography_5/MigrateToStateBased_9/3_CreditCardFormatterMigration.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/FullComposeOfficialDocumentation/Text_Typography_5/MigrateToStateBased_9/3_CreditCardFormatterMigration.kt" />
              <option name="updatedContent" value="package com.example.FullComposeOfficialDocumentation.Text_Typography_5.MigrateToStateBased_9&#10;&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.text.AnnotatedString&#10;import androidx.compose.ui.text.input.OffsetMapping&#10;import androidx.compose.ui.text.input.TransformedText&#10;import androidx.compose.ui.text.input.VisualTransformation&#10;&#10;/*&#10; Credit Card Formatter - Migration Example&#10; &#10; Old approach: VisualTransformation&#10; - Manually format text with dashes&#10; - Manually calculate offset mapping (complex!)&#10; - Maps cursor position between original and visual text&#10; &#10; New approach: InputTransformation + OutputTransformation&#10; - InputTransformation: Limit to 16 digits&#10; - OutputTransformation: Add dashes (no offset mapping needed!)&#10; - Offset mapping calculated automatically&#10;*/&#10;&#10;/*&#10; VALUE-BASED - Credit Card Formatter (Current approach)&#10; &#10; Formats as: XXXX-XXXX-XXXX-XXXX&#10; &#10; Complexity:&#10; - Must implement offsetMapping manually&#10; - originalToTransformed: maps original index → visual index&#10; - transformedToOriginal: maps visual index → original index&#10; - Easy to make mistakes in calculations&#10;*/&#10;@Composable&#10;fun OldTextFieldCreditCardFormatter() {&#10;    var state by remember { mutableStateOf(&quot;&quot;) }&#10;    &#10;    TextField(&#10;        value = state,&#10;        onValueChange = { &#10;            // Filter: only allow up to 16 digits&#10;            if (it.length &lt;= 16) state = it &#10;        },&#10;        visualTransformation = VisualTransformation { text -&gt;&#10;            // Making XXXX-XXXX-XXXX-XXXX string&#10;            var out = &quot;&quot;&#10;            for (i in text.indices) {&#10;                out += text[i]&#10;                if (i % 4 == 3 &amp;&amp; i != 15) out += &quot;-&quot;&#10;            }&#10;            &#10;            /*&#10;             OffsetMapping is complex!&#10;             Must manually calculate position mappings&#10;             &#10;             Example: User types &quot;1234567890123456&quot;&#10;             Visual shows: &quot;1234-5678-9012-3456&quot;&#10;             &#10;             If cursor is at position 5 in original (between 5 and 6):&#10;             Visual position should be 6 (after the dash)&#10;             &#10;             originalToTransformed(5) = 6&#10;             transformedToOriginal(6) = 5&#10;            */&#10;            TransformedText(&#10;                text = AnnotatedString(out),&#10;                offsetMapping = object : OffsetMapping {&#10;                    override fun originalToTransformed(offset: Int): Int {&#10;                        if (offset &lt;= 3) return offset&#10;                        if (offset &lt;= 7) return offset + 1&#10;                        if (offset &lt;= 11) return offset + 2&#10;                        if (offset &lt;= 16) return offset + 3&#10;                        return 19&#10;                    }&#10;                    &#10;                    override fun transformedToOriginal(offset: Int): Int {&#10;                        if (offset &lt;= 4) return offset&#10;                        if (offset &lt;= 9) return offset - 1&#10;                        if (offset &lt;= 14) return offset - 2&#10;                        if (offset &lt;= 19) return offset - 3&#10;                        return 16&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    )&#10;}&#10;&#10;/*&#10; STATE-BASED - Credit Card Formatter (Future approach)&#10; &#10; Much simpler! No manual offset mapping needed.&#10; &#10; Migration steps:&#10; 1. Replace value/onValueChange with rememberTextFieldState()&#10; 2. Replace onValueChange filtering with InputTransformation&#10; 3. Replace VisualTransformation with OutputTransformation&#10; 4. No need to calculate offset mapping!&#10; &#10; Example (requires newer Compose version):&#10; &#10; @Composable&#10; fun NewTextFieldCreditCardFormatter() {&#10;     val state = rememberTextFieldState()&#10;     &#10;     TextField(&#10;         state = state,&#10;         // InputTransformation: Limit to 16 characters&#10;         inputTransformation = InputTransformation.maxLength(16),&#10;         // OutputTransformation: Add dashes&#10;         outputTransformation = {&#10;             // Use TextFieldBuffer from receiver scope&#10;             // Just insert dashes at the right positions&#10;             if (length &gt; 4) insert(4, &quot;-&quot;)&#10;             if (length &gt; 9) insert(9, &quot;-&quot;)&#10;             if (length &gt; 14) insert(14, &quot;-&quot;)&#10;             // Offset mapping calculated automatically!&#10;         }&#10;     )&#10; }&#10; &#10; Benefits:&#10; - No manual offset calculation&#10; - Simpler, less error-prone code&#10; - Separation of concerns:&#10;   - InputTransformation: What goes into state&#10;   - OutputTransformation: How it's displayed&#10;*/&#10;&#10;/*&#10; Phone Number Formatter Example (value-based, current)&#10;*/&#10;@Composable&#10;fun OldPhoneNumberFormatter() {&#10;    var phone by remember { mutableStateOf(&quot;&quot;) }&#10;    &#10;    TextField(&#10;        value = phone,&#10;        onValueChange = { if (it.length &lt;= 10) phone = it },&#10;        visualTransformation = VisualTransformation { text -&gt;&#10;            var out = &quot;&quot;&#10;            for (i in text.indices) {&#10;                when (i) {&#10;                    0 -&gt; out += &quot;(&quot;&#10;                    3 -&gt; out += &quot;) &quot;&#10;                    6 -&gt; out += &quot;-&quot;&#10;                }&#10;                out += text[i]&#10;            }&#10;            &#10;            TransformedText(&#10;                text = AnnotatedString(out),&#10;                offsetMapping = object : OffsetMapping {&#10;                    override fun originalToTransformed(offset: Int): Int {&#10;                        return when {&#10;                            offset &lt;= 0 -&gt; offset&#10;                            offset &lt;= 3 -&gt; offset + 1&#10;                            offset &lt;= 6 -&gt; offset + 3&#10;                            offset &lt;= 10 -&gt; offset + 4&#10;                            else -&gt; 14&#10;                        }&#10;                    }&#10;                    &#10;                    override fun transformedToOriginal(offset: Int): Int {&#10;                        return when {&#10;                            offset &lt;= 1 -&gt; 0&#10;                            offset &lt;= 5 -&gt; offset - 1&#10;                            offset &lt;= 9 -&gt; offset - 3&#10;                            offset &lt;= 14 -&gt; offset - 4&#10;                            else -&gt; 10&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    )&#10;}&#10;&#10;/*&#10; STATE-BASED Phone Number (Future approach)&#10; &#10; @Composable&#10; fun NewPhoneNumberFormatter() {&#10;     val state = rememberTextFieldState()&#10;     &#10;     TextField(&#10;         state = state,&#10;         inputTransformation = InputTransformation.maxLength(10),&#10;         outputTransformation = {&#10;             if (length &gt; 0) insert(0, &quot;(&quot;)&#10;             if (length &gt; 4) insert(4, &quot;)&quot;)&#10;             if (length &gt; 8) insert(8, &quot;-&quot;)&#10;         }&#10;     )&#10; }&#10; &#10; Much cleaner and easier to maintain!&#10;*/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>